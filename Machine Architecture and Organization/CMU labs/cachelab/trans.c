/* Name: Hao Wang
 * X500: wang5167
 * A Matrix Wavefront Transport Function
 * 
 * trans.c - Matrix Wavefront A[i][j] = A[i-1][j-1] + A[i-1][j] + A[i][j-1]
 *
 * Each matrix wavefront transport function must have a prototype of the form:
 * void matrix_wavefront(int M, int N, int A[M][N]);
 *
 * A matrix wavefront transport function is evaluated by counting the number of misses
 * on a 512B and 4KB direct mapped cache with a block size of 32 bytes.
 */ 
#include <stdio.h>
#include "cachelab.h"

int is_matrix_wavefront(int M, int N, int A[M][N], int s, int E, int b);

/* 
 * matrix_wavefront_submit - This is the solution matrix wavefront function that you
 *     will be graded on for Part B of the lab submissions. Do not change
 *     the description string "Matrix Wavefront submission", as the driver
 *     searches for that string to identify the matrix wavefront function to
 *     be graded. 
 */

char matrix_wavefront_submit_desc[] = "Matrix Wavefront submission";
void matrix_wavefront_submit(int M, int N, int A[M][N], int s, int E, int b)
{
/*    for (int i = 1; i < M; i++) {
        for (int j = 1; j < N; j++) {
            A[i][j] = A[i-1][j] + A[i][j-1] + A[i-1][j-1];
        }
    }
*/
/* 255 = 3 * 5 * 17
   block   small   large
   3       72086   32774
   5       54474   48074
   15      39174   37126      
   17      38346   36554
   51      34326   33814
   85      50682   33290

*/
   int blocksize = 0;
   if(s==5){
    blocksize = 51;
   }
   if(s==8){
    blocksize = 3;
   }
    for(int row = 1; row < M; row += blocksize){
        for(int col = 1; col < N; col += blocksize){
            for(int i = row; i < row + blocksize; i++){
                for(int j = col; j < col + blocksize; j++){
                    A[i][j] = A[i-1][j-1] + A[i-1][j] + A[i][j-1];
                }
            }
        }
    }
}


/* 
 * You can define additional matrix wavefront functions below. We've defined
 * a simple one below to help you get started. 
 */ 

/* 
 * matrix_wavefront - A simple baseline matrix wavefront function, not optimized for the cache.
 */
char matrix_wavefront_desc[] = "Simple column-wise matrix wavefront calculations";
void matrix_wavefront(int M, int N, int A[M][N], int s, int E, int b)
{
    int i, j;

    for (j = 1; j < N; j++) {
        for (i = 1; i < M; i++) {
            A[i][j] = A[i-1][j-1] + A[i-1][j] + A[i][j-1];
        }
    }    
}

/*
 *     registerFunctions - This function registers your matrix wavefront
 *     functions with the driver.  At runtime, the driver will
 *     evaluate each of the registered functions and summarize their
 *     performance. This is a handy way to experiment with different
 *     matrix wavefront strategies.
 */
void registerFunctions()
{
    /* Register your solution function */
    registerTransFunction(matrix_wavefront_submit, matrix_wavefront_submit_desc); 

    /* Register any additional matrix wavefront functions */
    registerTransFunction(matrix_wavefront, matrix_wavefront_desc); 

}

/* 
 * is_matrix_wavefront - This helper function checks if matrix wavefront A is generated by above
 * definition . You can check the correctness of your matrix wavefront by calling
 *     it before returning from the matrix wavefront function.
 */
int is_matrix_wavefront(int M, int N, int A[M][N], int s, int E, int b)
{
    int i, j;

    for (i = 1; i < N; i++) {
        for (j = 1; j < M; ++j) {
            if (A[i][j] != (A[i-1][j-1] + A[i-1][j] + A[i][j-1]) ) {
                return 0;
            }
        }
    }
    return 1;
}

